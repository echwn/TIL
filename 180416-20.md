# 4/16(월)

## Today I learned

### 객체 이어서
#### 메소드
##### this
데이터와 동작을 합체해서 사용하기 위해 쓰는 메소드
##### Prototype
객체마다 사용되는 공통의 속성과 메소드를 Prototype이라는 기능을 이용해서 효율적으로 저장할 수 있다.
- 참조: 새로 생성된 객체, 배열, 함수(통)들은 그 안에 내용이 같더라도 서로 다른 것으로 취급 된다.
```js
{a: 1} === {a: 1} // false
[1, 2, 3] === [1, 2, 3] // false
(x => !x) === (x => !x) // false

const obj = {a: 1};
obj === obj // true
```
```js
function introduce() {
      return `안녕하세요, 제 이름은 ${this.name}입니다.`;
    }
// 사람을 나타내는 객체를 생성하는 팩토리 함수
function personFactory(name) {
  return {
    name,
    introduce // 객체 밖에서 생성한 걸 불러오기 때문에 여러번 생성 방지 
  };
}
```
- 프로토타입 상속(prototype inheritance): 객체를 상속받아 사용하는 JavaScript에서 만 쓰이는 기능, 부모는 하나 밖에 가질 수 없지만 부모의 부모는 가능.(프로토타입은 두 객체 사이의 관계이지만 상위 객체들을 통칭하는 용어로 프로토타입이라고도 함)
- 객체의 프로토타입을 지정하는 방법
	`Object.create`함수를 이용. 많이 쓰지않음 동작방식만 알아두길
- 프로토타입 체인: child에 속성이 없다면 프로토타입 객체의 속성을 확인해서 반환. 속성 접근자를 통해 프로토타입 체인을 전부 확인해서 반환하기 때문에 같은 이름의 속성이 프로토타입에 있을 경우 가져오기 힘듦(Property Shadowing)
```js
const parent = {
  a: 1
};
const child = {
  b: 2
};
Object.setPrototypeOf(child, parent);
console.log(child); // { 'b': 2 }
console.log(child.a); // 1 
```
프로토타입 체인의 마지막엔 `Object.prototype`이라는 객체가 항상 있고 `null`값을 가진다: `.isPrototypeOf``.hasOwnProperty`와 같은 메소드들이 안에 내장되어 있기 때문에가져다 쓸 수 있는 것.

##### 생성자 Constructor
객체를 만들 때 `new` 를 앞에 붙여서 호출하는 함수를 생성자라고한다. 주로 대문자로 시작하게 만듦.
```js
// 생성자 정의
function Person(name) {
  this.name = name; // 여기서 객체가 생성되는 것은 아님
}

// 생성자를 통한 객체 생성
const person1 = new Person('윤아준'); // 앞에 new를 붙이면 함수가 객체 생성자로 동작
```
return값이 아니라 생성된 객체(Instance)가 반환. 
- 인스턴스 Instance
`instanceof`연산자로 생성자와 객체(Instance)의 관계를 확인할 수 있다. 
```js
person1 instanceof Person; // true
```
**생성자에는 프로토타입이라는 속성이 내장되어 있다**
```js
Object.getPrototypeOf(person1) === Person.prototype; // true
```
`Person.prototype`이라는 객체가 프로토타입으로 자동 지정됨. `.constructor`라는 속성은 자기 자신을 저장하기 때문에 어떤 생성자에 의해 생성됐는 지 확인할 수 있다. 

```js
// 사람을 나타내는 객체를 생성하는 팩토리 함수
function personFactory(name) {
  return {
    name,
    introduce: function() {
      return `안녕하세요, 제 이름은 ${this.name}입니다.`;
    }
  };
}

const people = [];

for (let i = 0; i < 1000; i++) {
  people.push(personFactory('윤아준'))
}

people[0].introduce === people[1].introduce // false
```
위의 코드를 생성자와 프로토타입을 이용해 다시 작성하면 아래와 같다.
```js
// 사람을 나타내는 객체를 생성하는 팩토리 함수
function Person(name) {
  this.name = name; // 개별적으로 생성되는 속성 정의
}
Person.prototype.introduce = function() {
  return `안녕하세요, 제 이름은 ${this.name}입니다.`; // 공유되어야 할 속성은 프로토타입으로
};

const person = new Person('윤아준'); // person으로 속성을 붙여 쓸 수 있도록 객체 생성

person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다.'
```
### 배열 이어서
`typeof [];` // 결과값 'object'. 배열은 객체의 일종
배열은 `Array` 생성자의 인스턴스이다. 배열의 프로토타입으로 Array.prototype 객체가 지정되어 있다. 
- `reduce`메소드: 배열의 누적값(accumulator)을 구할 때 씀. 초기값을 항상 지정해 줘야한다.
	여러 인수들을 받을 수 있기 때문에 다른 메소드로도 구현 가능. 자유도가 높다.
#### 함수를 받아서 함수로 활용하기
`reduce`를 `map`처럼
```js
function map(arr, func) {
  return arr.reduce(
    (acc, item) => {
      acc.push(func(item));
      return acc;
    },
    []
  );
}
```
`reduce`를 `filter` 처럼
```js
function filter(arr, func) {
  return arr.reduce(
    (acc, item) => {
      if (func(item)) {
        acc.push(item);
      }
      return acc;
    },
    []
  );
}
```
`reduce`를 `sort` 처럼 
```js
function sort(arr, func) {
  return arr.reduce(
    (acc, item) => {
      let i;
      for (i = 0; i < acc.length; i++) {
        if (func(item, acc[i]) < 0) {
          break;
        }
      }
      acc.splice(i, 0, item);
      return acc;
    },
    []
  );
}
```
#### 배열이 특정 조건을 만족하는지 판별하기 (배열의 세 메소드)
`includes`indexOf와 비슷하지만 진리값을 반환 
`every` 전부 true여야 true
`some` 요소 중 하나라도  true라면 true

## 2. Today I found out

프로토타입의 개념이 알듯 말듯 이해하기 어려웠지만 클래스를 만나기 전의 통과의례라고 생각하면서 꾸역꾸역 들었다.